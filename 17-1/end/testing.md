### 고수준 테스팅

- #### 개발 프로세스와 테스팅 프로세스의 대응관계
  - 요구사항 - 인수 테스트
  - 개발목적 - 시스템 테스트
  - 외부명세 - 기능 테스트
  - 시스템설계 - 통합 테스트
  - 프로그램 구조 설계 - 통합테스트
  - 모듈 인터페이스 명세 - 모듈 테스트
  - 코드

- #### 기능 테스팅(Function Testing)
  - 프로그램과 외부명세의 차이를 찾는 프로세스
  - 외부 명세는 최종 사용자 관점에서 프로그램 동작을 상세히 기술한 것
  - 일반적으로 블랙박스 활동이다.
  - 프로그램이나 외부 명세의 불일치를 찾는 것이지, 프로그램의 외부 명세 충족 여부 확인이 아니다.

- #### 시스템 테스팅(System Testing)
  - 시스템이나 프로그램 기능을 테스트하는 프로세스가 아니다
  - 시스템이나 프로그램을 원래의 목표와 비교하는 것
    - 제품이 프로그램이라면 시스템 테스팅은 프로그램이 전체적으로 개발 목적을 충족하지 않는다는 것을 찾아내는 프로세스이다.
    - 문서화되고 측정 가능한 제품의 개발 목적이 없다면, 본질적으로 시스템 테스팅은 이루어 질 수 없다.

  - ##### 편의 테스팅(Facility Testing)
    - Facility(특징)이 실제로 구현되었는가 확인하는 테스팅
    - ex) 사용자는 위치와 범위를 지정할 수 있어야.., 구문 표현 규칙은 일관되어야..
  - ##### 볼륨 테스팅
    - 프로그램이 대량의 데이터를 처리해보도록 하는 것

  - ##### 스트레스 테스팅
    - 프로그램이 과도한 부하나 스트레스 상황에서의 작동 여부를 확인하는 것
    - 과도한 스트레스는 짧은 기간 동안 발생한 최대 용량의 데이터와 작업을 말한다.
    - 볼륨테스트는 타자수가 대량의 리포트에 대해 입력 가능 여부를 확인하는 것이고  
      스트레스 테스트는 타자수가 분당 50단어의 속도를 유지할 수 있는지 여부를 확인하는 것이다.
  - ##### 사용성 테스팅(Usability Testing)
    - 소프트웨어 테스트를 실제 사용자가 사용하는 환경에서 최종 사용자에게 맡김으로써 가장 공격적인 테스팅 방법인 자동화 테스트에서도 찾지못하는 잠재적인 문제점을 발견할 수 있다
  - ##### 보안성 테스팅(Security Testing)
    - 테스트 대상 프로그램의 보안 목적을 토대로 일련의 절차를 거쳐 프로그램의 보안 기능을 파괴하는 테스트케이스를 고안하고 실행하는 프로세스
  - ##### 성능 테스팅(Performance Testing)
    - 일정량의 부하와 설정 조건에서 응답 시간과 처리율 같은 부분을 테스팅
  - ##### 스토리지 테스팅(Storage Testing)
    - 프로그램은 시스템 메모리 사용을 제어할 수 있으며, 호스트 내에서 운용중인 다른 프로세스에 부정적인 영향을 미치지 않아야함을 확인
  - ##### 구성 테스팅(Configuration Testing)
    - 하드웨어 장치의 각 종류와 최고 구성과 최대 구성의 조합을 테스트
    - 운영체제마다, 웹브라우저마다 테스팅하는 것
  - ##### 호환성/전환 테스팅
    - 기존 시스템에서 그들의 특정한 호환성과 관련한 구체적인 목표를 테스팅
    - ex) 워드 프로세스 애플리케이션이 새 버전에서 이전 문서 포맷을 지원하는지 확인하는 것
  - ##### 설치성 테스팅(Installation Testing)
    - 말그대로 설치가 잘되는지 테스트
    - 특히 프로그램 패키지의 일부분인 경우 더욱 중요
  - ##### 신뢰성 테스팅(Reliability Testing)
    - ex) 99.97% 이상의 가동시간을 목표로한다.
    - 에 대한 테스팅
  - ##### 회복 테스팅(Recovery Testing)
    - 오류를 복구하는 방법을 기술한 회복성 목표를 달성하는지 테스팅
  - ##### 서비스가능성/유지보수 테스팅(Serviceability/Maintenance Testing)
    - 서비스가능성, 유지보수 특성에 대한 목표를 달성하는지에대한 테스팅
  - ##### 문서 테스팅
    - 사용자 문서의 정확성을 테스팅
  - ##### 절차 테스팅(Procedure Testing)
    - 최종 사용자를 위한 절차와 같이 규정된 사용절차는 시스템 테스팅 단계에서 테스트해야한다.

  - ##### 시스템 테스팅 수행
    - 누가 시스템 테스트를 수행하는가
      1. 프로그래머는 시스템 테스트를 수행하면 안되고
      2. 많은 테스트 중에서 프로그램 개발 조직이 수행해서는 절대로 안된다
      ---
      1. 시스템 테스트를 수행하는 사람은 반드시 최종 사용자처럼 생각해야한다
      2. 시스템 테스팅을 전문으로하는 몇명의 시스템 테스트 전문가, 한두명의 최종 사용자 대표, 인간 공학자, 프로그램 초기에 참여했던 핵심 분석가 또는 설계자와 같이 시스템 테스팅 팀을 구성하는것이 가장 이상적

- #### 인수 테스팅(Acceptance Testing)
  - 테스팅 대상 프로그램과 초기 요구 사항 및 현재 사용자의 요구를 비교하는 프로세스

- #### 설치 테스팅(Installation Testing)
  - 설치 과정 중 발생하는 오류 발견을 위한 테스트

- #### 좋은 테스트 계획의 요소
  - 목표
  - 완료 기준
  - 일정
  - 책임
  - 테스트 케이스 라이브러리와 표준
  - 도구
  - 연산시간
  - 하드웨어 구성
  - 통합
  - 추적 절차
  - 디버깅 절차
  - 리그레션 테스팅


  ------------------

### 사용성 테스팅

- 뭔가?
  - 소프트웨어 테스트를 실제 사용자가 사용하는 환경에서 최종 사용자에게 맡김으로써 가장 공격적인 테스팅 방법인 자동화 테스트에서도 찾지못하는 잠재적인 문제점을 발견할 수 있다
  - 설계 결함으로 인한 소프트웨어의 인체공학적 실수를 발견하고자 하는 것

- 어떤 특징이 있나?
- 데이터 수집 방법(Data-Gathering Methods)
  - **사용자에게 비디오 테이프로 녹화하기(Videotaping a user)**
      - 사고 방식의 프로토콜
      - 단점은 부 자연스러운 사용자 환경이 될 수 있습니다.
  - **원격 테스트(Remote Testing)**
    - 친숙한 환경에 사용자 배치
    - 개발자가 피드백을받지 못할 수 있다는 단점
    - 추가 소프트웨어 설치(추가적인 시간이 걸림)
  - **아이 트래킹(Eye tracking)**
    - 관찰자가 특정 시각 요소에서 얼마나 오랫동안 멈추는 지
    - 관찰자의 관심을 끄는 시각적 요소

---

### 디버깅

- 잘 설계된 테스트 케이스 실행 후 수행하는 작업
- 프로그램이 설계된 대로 실행하지 않음을 보인 뒤에 수행하는 작업
- 오류위치를 파악하는 문제가 95%를 차지
- #### 단계
  1. 프로그램 내의 의심되는 요류의 위치와 정확한 특성 파악
  2. 오류를 수정

 - #### 무차별 디버깅(Debugging by Brute Force)
   - 저장된 dump를 이용한 디버깅
   - 프로그램코드에서 화면 프린트 구문을 이용한 일반적인 디버깅
   - 자동화 디버깅 도구를 이용한 디버깅
- #### 귀납적 디버깅(Debugging by Induction)
  - 데이터를 수집해서 가장 가까운 애를 찾는 방법
  - 어떤 상황의 세부적인 것으로부터 전체를 유추하는 사고과정
    ![캡처](http://i.imgur.com/QOlbvFB.png)
  - 적절한 데이터 수집, 데이터 구성, 관계성 연구, 가설 고안, 가설입증, 에러 수정

- #### 연역적 디버깅(Debugging by Deduction)
  - 후보군을 줄여가며 찾아가는 방법
  - 어떠한 일반적인 이론이나 전제로부터 시작하여 제거와 정제의 과정을 거쳐 결론(오류의 위치)에 도달하는 것
  ![캡처](http://i.imgur.com/RBT833T.png)
  - 가능한 원인 열거, 제거절차 사용, 남은 가설 정제, 남은 가설 증명, 에러수정, 더 많은 데이터 수집

- #### 역 추적에 의한 디버깅(Debugging by Backtracking)
  - 로직을 벗어난 지점을 발견할 때까지 프로그램의 로직을 따라가며 부정확한 결과를 역추적하는 것

- #### 테스팅에 의한 디버깅(Debugging by Testing)
  - 테스트를위한 테스트 케이스는 'fat'한 경향이있다.
    - 적은 수의 테스트 케이스에서 많은 조건을 커버
  - 디버깅을위한 테스트 케이스는 'slim'하다.
    - 각 테스트 케이스에서 하나의 조건 또는 몇 가지 조건 만 포함

- #### 디버깅 원칙
  - **오류 발생 위치 파악의 원칙(Error-Locationg Principles)**
    - Think
      - 조용한곳
      - 프로그램의 코드를 보지 않고, 프로그램이 어떻게 설계되었는지, 소프트웨어가 잘못 수행되는 위치는 어디인지 마음 속으로 검토한다
      - 올바른 성능을 위해 프로세스에 집중하고 코드가 잘 못 설계 될 수 있는 방법을 떠올려본다
    - 난국에 부딪히면 잠시 쉬어라
    - 차선책으로 디버깅 도구를 사용해라
    - 실험은 피하되 최후의 수단으로 사용하라
  - **오류수정 기법(Error-Reparing Techniques)**
    - 버그가 하나 있는 곳엔 다른 버그가 있을 가능성이 높다
    - 오류의 증상이 아닌 오류를 고쳐라
    - 정확히 수정될 확률은 100%가 아니다
    - 프로그램이 커지면 정확히 수정될 확률은 낮아진다
    - 수정 과정에서 오류를 유발 할 수 있다
    - 오류 수정 프로세스에서는 잠시 설계 단계로 되돌아갈 필요가 있다
    - 오브젝트 코드를 변경하지 말고 소스 코드를 변경하라

  - #### 오류 분석(Error Analysis)
    - 오류 제거 외에도 디버깅은 또 다른 중요한 효과를 가져올 수 있다
      - 디버깅은 아직 드러나지 않은 소프트웨어 오류의 본질에 대하여 무언가를 알려줄 수 있다.
      - 피드백 제공
    - 다음과 같은 것이 포함될 수 있다
      - 어디서 오류가 발생되었는가?
      - 누가 오류를 만들었는가?
      - 무엇이 잘못되었는가?
      - 어떻게하면 오류를 예방할 수 있는가?
      - 왜 오류를 초기에 발견하지 못했을까?
      - 어떻게 하면 오류를 초기에 발견할 수 있을까?

### 애자일 환경에서의 테스팅

- #### 애자일 테스팅
  - 모든 사람이 테스트 계획의 설계, 구현 및 실행을 통해 프로세스에 참여하는 협력 테스트의 한 종류
  - 애자일 테스트는 가능한 빠른 시점부터 전체 개발 과정 동안 고객의 참여를 필요로 한다

- #### XP와 테스팅
  - XP에서는 테스팅이 너무나 중요하기 때문에 단위 테스트와 인수 테스트를 선행한 후 코드 베이스를 작성하도록 요구한다. 이러한 형식의 테스팅을 적절히 표현하는 것이 **익스트림 테스팅(XT,eXetreme Testing)**

- #### XP의 기초
  - XP의 초점
    - 단순한 설계 구현
    - 개발자와 고객 간의 의사 소통
    - 지속적인코드 베이스 테스팅
    - 사양 변경을 수용하기 위한 리팩토링
    - 고객의 피드백 검색

- 애자일 개발 프로세스는 엄격하게 채택 될 경우 개발자가 기존 소프트웨어 개발 모델을 사용하는 것보다 빠른 속도로 고객을위한 고품질 소프트웨어를 만들 수있는 방법을 제공합니다.
- Extreme Testing에서는 응용 프로그램 코딩을 시작하기 전에 프로그램 사양을 기반으로 테스트 하네스를 만들어야합니다.
- 이런 식으로 단위 테스트를 통과하도록 응용 프로그램을 설계하므로 사양을 충족 할 확률이 높아집니다.

### 테스트 주도 개발 (TDD: Test Driven Development)

- TDD는 단위 테스트에 중점을 둡니다.  
  그러나 Unit Testing은 TDD와 같은 것이 아닙니다.  
  논리를 먼저 작성한 다음 테스트를한다면 - 단위 테스트로 간주 될 수 있지만 TDD는 고려되지 않습니다  
  TDD는 우리가 먼저 테스트를 작성하도록 요청한 다음 로직을 작성합니다  
  우리는 로직이 이미 존재하는 것처럼 테스트를 작성합니다.  
  아직 존재하지 않는 코드에 대한 테스트를 작성할 수 있습니다.  
  테스트를 처음 실행하면 실패합니다!  

- #### TDD 방법
  1. 먼저 실패하는 테스트 케이스를 작성해라
  2. 테스트를 통과하기 위한 최소한의 코드를 작성해라
  3. 좋은 기준에 도달하기 위해 로직을 재정의해나가라.

- #### 혼란스러워 하지 말 것
  1. 우리는 전체 프로젝트에 대한 모든 테스트를 먼저 작성하지 않을 것입니다.
  2. 먼저 단일 테스트를 작성합니다. 이는 단일 메소드에 대한 테스트 일 수 있습니다.
  3. 그런 다음 테스트를 통과하는 논리를 작성합니다.

- #### 이점
  - 우리의 클래스 나 메소드를 코딩하면서 명확성과 방향을 제시합니다.
  - 그것은 당신이 개발해야하는 것에 초점을 맞추어줌으로써 스코프 크리프를 방지합니다.
  - 단위 테스트 할 수있는 코드를 작성하는 데 주력하므로 더 많은 모듈화 된 코드로 이어질 수 있습니다.

- 결론
  - 지금 우리 코드가 우리의 테스트에 의해 어떻게 이끌어 지는지 분명해야합니다.
  - TDD는 단위 테스트를 작성하는 것과 동일하지 않습니다.

### 웹 어플리케이션 테스팅
- #### Testing Challenge 테스팅 과제
  인터넷 기반 응용 프로그램에는 테스트 방법을 설계 할 때 고려해야 할 많은 실패 지점이 있습니다.
  - **다양하면서 대규모인 사용자 기반**
    - 사용자는 다른 사용경험과 사용능력을 보유하고 다양한 브라우저를 선택하며 다른 운영체제와 다른 기기를 사용한다
  - 비즈니스 환경
    - .
  - Locales : 언어 번역, 시간대 차이 및 통화 변환과 같은 국제화 문제
  - 보안
  - 테스트 환경
    - 어플리케이션을 적절히 테스팅하려면 실제와 같은 별도의 테스팅 환경이 필요
    - 웹 서버, 응용 프로그램 서버, 데이터베이스 서버, 네트워크 장치

- #### 3계층 티어
  - **Presentation Tier**
    - 사용자 인터페이스(UI,GUI)를 제공하는 인터넷 응용 프로그램 계층
    - 내용 테스팅
      - 전반적인 미학 폰트, 색상, 오타, 내용 정확도, 기본값
    - 웹사이트 아키텍처
      - 잘못된 링크나  그림
    - 사용자 환경
      - 웹브자우저 버전과 운영체제 구성
  - **Business Tier**
    - 사용자 인증 및 트랜잭션과 같은 비즈니스 프로세스를 모델링하는 계층
    - 성능
      - 애플리케이션이 성능 명세를 충족하는지 테스트
    - 데이터 유효성
      - 수집된 고객 데이터에서 오류를 발견하는 테스트
    - 트랜잭션
      - 신용카드 처리, 이메일 검증, 판매세 계산 등 트랜잭션 처리에서 오류를 발견하는 테스트
  - **Data Tier**
    - 응용 프로그램에서 사용하거나 최종 사용자로부터 수집된 데이터를 저장하는 계층
    - 응답시간
      - 구조적 쿼리 언어 운영을 위한 완료 시간을 나타냄
    - 데이터무결성
      - 데이터가 정확하고 올바르게 저장되어 있는 것을 검증
    - 결함 허용성과 회복성
      - MTBF를 극대화하고 MTTR을 최소화

### 모바일 어플리케이션 테스팅

- 모바일 디바이스란
  - 무선의 또는 위성 데이터 링크를 통해 네트워크 기반 어플리케이션을 실행 할 수 있는 기능을 가진 것
- 모바일 어플리케이션
  - 모바일 디바이스에서 실행되는 네트워크 기반 프로그램

- #### Testing Challenges
  - 장치 다양성
    - 더 많은 장치와 더 많은 고려사항들
    - 장치의 다양성
    - 운영체제, 브라우저, 응용프로그램 런타임 환경
    - 장치의 다양성은 프론트와 센터의 사용성 테스팅을 강요한다
  - 스크립팅
    - 테스트 스크립트 생성 및 실행
  - 사용성
    - 모바일 앱을 사용하기 쉽도록 만들어라
    - 고객에게 만족스러운 사용자 경험을 제공해라
 - **적당한 시간 내에 버그를 탐지하는 경제적인 테스트 계획에 도달하려면**  
 **시간, 재정 및 인력 자원과 균형을 이루어야한다**

- #### Testing Approaches
  - 인터넷 응용프로그램 테스트와 유사하다
  - 주요 차이점은 기기 자체 테스트 방법에 있다

  - **Presentation layer**
    - UI를 제공
    - 전통적인 인터넷 테스트와 다릅니다 (테스트 컨텐트와 웹 사이트 아키텍처 개념은 여전히 ​​적용됩니다)
    - 글꼴, 색상, 철자, 내용 정확도, 깨진 링크 또는 그래픽
    - 장치 테스트 관련
    - 실제 장치로 테스트와 에뮬레이터로 테스트
  - **Business logic**
    - 사용자 인증 및 트렌잭션 같은 로직
    - 성능 사양, 데이터 검증 루틴 및 트랜잭션 처리 구성 요소
  - **Data stores**
    - 응용프로그램에서 사용하거나 최종 사용자로부터 수집한 데이터를 저장
    - 응답시간
    - 데이터 무경설, 내결함성 및 복구 가능ㅇ성

- #### 실제 장치로 테스트
  - **장점**
    - 사용자 경험에 대한 진정한 느낌 얻기
    - 실제 장치로 특정 사례 테스트 가능
      - 통신사 네트워크의 신뢰성
      - 수신전화의 영향 결정
    - 어플리케이션의 작동 방식 평가
      - 속도 빠름?
      - 이뻐보임?
      - 장치 전체에서 일관성 있음?
    - 장치별 버그 결정
  - **단점**
    - 비쌈
    - 네트워크 가용성
    - 수동 프로세스
      - 발생하기 쉬운 오류
      - 다른 비용이 프로세스에 추가됨

    - 대안
      - 기기대여
      - 일반 작업을 지정하는 작성된 수동 스크립트르 사용

 - #### 에뮬로 테스팅
   - **장점**
     - 저렴하고 빠른 테스트 허용
       - 프로그램 사양에 맞지 않는 이벤트 및 상황을 찾는데 도움
      - 간단한 관리(PC에서 실행)
      - 대부분의 에뮬은 여러 장치를 지원
      - 더 많은 리소스가 있는 컴퓨터에서 실행
      - 대부분 에뮬레이터는 고급 스크립팅 언어를 사용
        - 일관되고 자동화 된 테스트를 생성 가능
        - 수작업 테스트보다 오류가 발생하기 쉽고 빠름
    - **단점**
      - 장치 관련 버그를 식별 할 수 없음
