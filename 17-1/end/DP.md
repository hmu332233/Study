## Structural

- ### Adapter
  - 한 클래스의 인터페이스를 클라이언트에서 사용하자고 하는 다른 인터페이스로 변환한다.
  - 인터페이스 호환성 때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다.

- ### Flyweight
  - 공통으로 사용되는 객체는 새로 생성해서 사용하지 않고 공유를 통해 효율적으로 자원을 활용하는 패턴
  - Factory를 이용해 이미 가지고 있는 객체에 대한 요청이 들어왔을 때는 관리하고 있떤 객체를 리턴하고,  
    가지고 있지 않은 객체를 요청하면 새로 객체를 만들어 관리 리스트에 추가하고 리턴한다.

## Concurrency

- ### Two-Phase-Termination
  - 이름 그대로 두 단계 종료라는 뜻으로 한 작업을 종료 시킬 때 바로 종료하는 것이 아니라  
    종료 요청, 종료 처리 이렇게 두 단계로 나누어 종료하는 방법의 패턴
  - 작업 중인 쓰레드에 대해서 종료를 요청했을 때 즉각적으로 종료하면 생길 문제를 방지해주는 효과가 있다

- ### Future
  - 클라이언트가 다른 쓰레드에 처리를 의뢰하고 그 결과 값을 받아야할 때  
    실행결과를 기다리고 있으면 응답성이 저하되어 비효율적이다.
  - 그래서 Future를 만들어 처리 개시 시점에 반환하고 처리 결과는 나중에 Future에 set해준다  
    이렇게하면 클라이언트는 Future를 통해 처리결과를 원하는 타이밍에 얻는게 가능해진다

## Behavior

- ### Command
  - 한 클래스마다 공통된 기능을 분리하여 관리하고 이들의 실행을 관리하는 클래스를 두어  
    그 히스토리를 기록한다. 이를 통해 undo나 redo 같은 기능을 사용할 수 있는 패턴
- ### Visitor
  - 각 클래스 별로 공통된 메소드이나 그 내부 구현이 각각 다른 메소드를 추가해야할 때  
    로직과 데이터 구조를 분리하여 visitor가 각 객체들을 순회하며 동작을 수행하도록한다.
  - 로직을 분리하여 관리함으로써 기능 추가시 각 클래스를 수정하지 않고 확장을 통해 기능을 추가할 수 있다.
- ### State
  - 클라이언트는 Context에게 동일한 request를 호출하지만 현재 상태(state)에 따라 서로 다른 행위가 수행되도록 하는 패턴
  - 이 때 객체의 상태에 따라 각각의 행위를 변경할 수 있도록 분리하여 캡슐화한다.
- ### Template Method
  - 상위 클래스에서 처리의 흐름을 제어하고  
    하위 클래스에서 처리의 내용을 구체화하여 사용하는 방식의 패턴
  - 일반 abstract class는 비즈니스 프로세스를 정의하는데 제약이 없지만  
    템플릿 메소드는 비즈니스 프로세스를 미리 정의하여 사용함으로써 이에 제약이 있다

## Partitioning

- ### Composite
  - 객체와 객체그룹을 구분없이 하나의 인터페이스로 다룰 수 있게한다.
  - 객체(Leaf)와 구성(Composite)을 트리로 구성하여 하나의 인터페이스에서 사용하도록 고려한 패턴
